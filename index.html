<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>

@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}

.client {
  fill: rgb(150,150,150);
  stroke: black;
  stroke-width: 0;
}

.transmitter {
  stroke-width: 3;
  stroke-opacity: .3;
}

.cover {
  stroke-width: 2;
  stroke: black;
  stroke-opacity: .5;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Telecom Tower Covering</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      <p>
      </p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>
      <p>
      Let $R$ be the set of regions. For each of these regions we associate a binary variable
      which we index by $j$
      \[
      r_j = \left\{\begin{array}{ll}
             1 & \text{if community $j$ is covered}\\
             0 & \mathrm{otherwise}
            \end{array}\right.
      \]
      The population in region $j$ is denoted by $p_j$.
      </p>
      <p>
        Let $T$ be the set of potential sites where we can build the towers. We associate a binary
        variable with each of these sites which we index by $i$
      \[
      t_i = \left\{\begin{array}{ll}
             1 & \text{if tower $i$ is built}\\
             0 & \mathrm{otherwise}
            \end{array}\right.
      \]
      The cost of setting up the tower at site $i$ is denoted by $c_i$.
      </p>
      <p> Furthermore we add binary constants indexed by $i$ and $j$ such that
      \[
      \text{cover}_{ij} = \left\{\begin{array}{ll}
             1 & \text{if tower $i$ covers region $j$}\\
             0 & \mathrm{otherwise}
            \end{array}\right.
      \]</p>
      <p> Now if a region $r_j$ is covered ($r_j = 1$) then we must have a tower built at site $t_i$ ($t_i = 1$)
      which covers region $j$ ($cover_{ij} = 1$). Now, we can have more than one tower covering a region, so this
      yields the constraint
      \[
      \sum_{i \in T} \text{cover}_{ij} t_{i} \geq r_j
      \]
      for each region $r_j \in R$</p>
      <p> In addition, we cannot exceed the allocated budget. So we have the constraint
      \[
      \sum_{i \in T} c_{i} t_{i} \leq \text{budget}
      \]
      </p>
      <p> We seek to maximise the total population covered by the towers, so finally the problem becomes

       \[
      \begin{array}{ll}
      \text{maximize} & \sum_{j \in R} p_j r_j \\
      \text{subject to} & \sum_{i \in T} \text{cover}_{ij} t_{i} \geq r_j \quad \forall r_j \in R\\
                        & \sum_{i \in T} c_{i} t_{i} \leq \text{budget} \\
                        & t_i \in \{ 0, 1 \} \\
                        & r_j \in \{ 0, 1 \}
      \end{array}
      \]

      in the variables $t_i$ and $r_j$.
      </p>
    </div>
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
      ### DATA FROM XPRESS, CHANGE IT ###
      pop = [2, 4, 13, 6, 9, 4, 8, 12, 10, 11, 6, 14, 9, 3, 6]
      sites = [[0,1,3], [1,2,4], [3,6,7,9], [4,5,7,8], [7,8,11],
          [6,9,10,11,14], [11,12,13,14]]
      cost = [1.8, 1.3, 4.0, 3.5, 3.8, 2.6, 2.1]
      budget = 10

      from gurobipy import *

      numR = len(pop) # Number of regions
      numT = len(sites) # Number of sites for towers

      # Create cover matrix
      cover = {};
      for i in range(numT):
          for j in range(numR):
              if (j in sites[i]):
                  cover[(i,j)] = 1
              else:
                  cover[(i,j)] = 0

      m = Model()

      t = {} # Binary variables for each site
      r = {} # Binary variable for each community

      for i in range(numT):
          t[i] = m.addVar(vtype=GRB.BINARY, name="t%d" % i)

      for j in range(numR):
          r[j] = m.addVar(vtype=GRB.BINARY, name="r%d" % j)

      m.update()

      for j in range(numR):
          m.addConstr(quicksum( cover[(i,j)]*t[i] for i in range(numT) ) >= r[j])

      m.addConstr(quicksum( cost[i]*t[i] for i in range(numT) ) <= budget)

      m.setObjective(quicksum( pop[j]*r[j] for j in range(numR) ), GRB.MAXIMIZE)

      m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p> Note that region is counted as covered only if it is entirely covered by one cell tower
      (restriction on data or something like that)</p>

      <p> Stuff that could be added: ABility to change budget, ability to change radius of the towers.</p>

      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

var budget = 10;
var population = 1;
var radius = 200;
var polyVertices = [];
var formatAsPercentage = d3.format(".1%")

//Width and height
var width = 800;
var height = 500;

var voronoi = d3.geom.voronoi()
    .clipExtent([[0, 0], [width, height]]);

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height)
              .on("mousedown", addPoint);

var backgroundG = svg.append("g");
backgroundG.append("rect")
           .attr("x", 0)
           .attr("y", 0)
           .attr("width", width)
           .attr("height", height)
           .attr("fill", "rgb(233,233,233)");

// Initial points
var vertices = d3.range(50).map(function(d) {
  return [Math.random() * (width), Math.random() * (height) ];
});

var transmitters = [[100, 100], [300, 400], [600, 50], [700, 400], [350, 250], [50, 400], [400, 70], [600, 250], [169, 262.875], [485, 445.875]];

// G object for voronoi
var pathG = svg.append("g");

// G object for points
var circleG = svg.append("g");

// G object for solution
var solutionG = svg.append("g");

// G object for transmitters
var transG = svg.append("g");

circleG.selectAll("circle")
       .data(vertices)
       .enter()
       .append("circle")
       .attr("cx", function(d) { return d[0]; })
       .attr("cy", function(d) { return d[1]; })
       .attr("class", "client")
       .attr("r", 2);

var transSelection = transG.selectAll("circle")
                          .data(transmitters)
                          .enter()
                          .append("circle")
                          .attr("cx", function(d) { return d[0]; })
                          .attr("cy", function(d) { return d[1]; })
                          .attr("class", "transmitter")
                          .attr("r", 7);

transSelection.attr("fill", "purple").attr("stroke", "purple");

redraw();

function inArray (array, point) {
  var p0 = point[0];
  var p1 = point[1];
  var bool = false;
  for (i = 0; i < array.length; i++) {
    pointprime = array[i];
    if (p0 === pointprime[0] && p1 === pointprime[1]) {
      bool = true;
      break;
    }
  }
  return bool;
}

function addPoint() {
  var point = d3.mouse(this);
  console.log(point)
  if (inArray(vertices, point)) {
    console.log('point already exists!');
    return;
  }
  vertices.push(point);
  circleG.append("circle")
         .attr("cx", point[0])
         .attr("cy", point[1])
         .attr("class", "client")
         .attr("r", 2);
  solutionG.selectAll("circle").remove("circle");
  solutionG.selectAll("path").remove("path");
  solutionG.selectAll("text").remove("text");
  redraw();
}

function redraw() {
  pathG.selectAll("path").remove("path");

  polyVertices = [];

  pathG.selectAll("path")
       .data(voronoi(vertices))
       .enter()
       .append("path")
       .attr("d", function(d) {
          var polyPoints = [];
          for (var i = 0; i < d.length; i++) {
            polyPoints.push(d[i]);
          }
          polyVertices.push(polyPoints);
          return "M" + d.join("L") + "Z";
        })
       .attr("fill", "none")
       .attr("stroke-width", 2)
       .attr("stroke", "gray");

  console.log('polyVertices', polyVertices);
}

// Function that actually joins the different points of polygon
function polygon(d) {
  return "M" + d.join("L") + "Z";
}

// Function to compute square distance between two points
function sqDist(a,b) {
  dx = a[0] - b[0];
  dy = a[1] - b[1];
  return (dx*dx + dy*dy);
}

function compute() {
  var pop = [];
  for (var i = 0; i < vertices.length; i++) {
    pop.push(population);
  }

  // For sites check all points that are within distance of tower
  var sites = [];
  for (var i = 0; i < transmitters.length; i++) {
    var site = [];
    for (var j = 0; j < polyVertices.length; j++) {
      // Region is covered if and only if all vertices of the polygon
      // are within the radius of a tower
      var polyPoint = polyVertices[j];
      var inside = 1;
      for (var k = 0; k < polyPoint.length; k++) {
        if (sqDist(transmitters[i], polyPoint[k]) > radius*radius) { inside = 0; }
      }
      if (inside) { site.push(j) };
    }
    sites.push(site);
  }

  console.log('sites', sites);

  // Each site has the same price
  var cost = [];
  for (var i = 0; i < transmitters.length; i++) {
    cost.push(1.8);
  }

  d3.json('/telecom')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'pop': pop,
                          'sites': sites,
                          'cost': cost,
                          'budget': budget}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];
          var solTowers = solution[0];
          var solRegions = solution[1];

          console.log('towers', solTowers);
          console.log('regions', solRegions);

          var towers = [];
          for (var i = 0; i < solTowers.length; i++) {
            if (solTowers[i] > .5) {
              towers.push(transmitters[i]);
            }
          }

          var covered = 0;
          for (var i = 0; i < solRegions.length; i++) {
            if (solRegions[i] > .5) {
              covered = covered + 1;
            }
          }
          covered = covered/solRegions.length; // percentage of regions covered

          transSelection.attr("fill", function(d, i) { if (solTowers[i] > .5) { return "green"; }
                                                       else { return "rgb(150,0,0)"; }
                                                     })
                        .attr("stroke", function(d, i) { if (solTowers[i] > .5) { return "green"; }
                                                       else { return "rgb(150,0,0)"; }
                                                     });


          solutionG.selectAll("circle").remove("circle");

          var signalArea = solutionG.selectAll("circle")
                    .data(towers)
                    .enter()
                    .append("circle")
                    .attr("cx", function(d) { return d[0]; })
                    .attr("cy", function(d) { return d[1]; })
                    .attr("class", "cover")
                    .attr("fill", "green")
                    .attr("r", 1)
                    .attr("opacity", 0);

          signalArea.transition()
                    .duration(500)
                    .delay(function(d, i) { return i*50; })
                    .attr("r", radius)
                    .attr("opacity", .1);

          solutionG.selectAll("path").remove("path");

          var solutionVoro = solutionG.selectAll("path")
               .data(voronoi(vertices))
               .enter()
               .append("path")
               .attr("d", polygon)
               .attr("opacity", 0)
               .attr("fill", function(d,i) {
                                if ( solRegions[i] > .5 ) {
                                  return "green";
                                } else {
                                  return "none";
                                }
                             })
               .attr("stroke-width", 2)
               .attr("stroke", function(d,i) {
                                if ( solRegions[i] > .5 ) {
                                  return "rgb(102,0,102)";
                                } else {
                                  return "none";
                                }
                             });

          solutionVoro.transition()
                    .duration(500)
                    .delay(function(d, i) { return 500 + i*30; })
                    .attr("opacity", .5);

          solutionG.selectAll("text").remove();

          var coveredText = solutionG.append("text")
              .text(formatAsPercentage(covered) + " Coverage")
              .attr("x", width/2)
              .attr("y", 40)
              .attr("font-family", "sans-serif")
              .attr("font-size", "20px")
              .attr("fill", "white")
              .attr("text-anchor", "middle")
              .attr("opacity", 0);

          coveredText.transition()
                    .duration(500)
                    .attr("opacity", 1);
      }
   }
}
</script>
